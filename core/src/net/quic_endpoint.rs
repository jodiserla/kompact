use async_std::fs::write;
use async_std::stream;
use bytes::{BytesMut, BufMut, Bytes};
use tracing::dispatcher;
use tracing::log::logger;
use uuid::Variant;
use super::*;
use quinn_proto::{
    EcnCodepoint, 
    ConnectionHandle, 
    Connection, 
    DatagramEvent,
    EndpointEvent,
    ConnectionEvent, 
    Transmit, 
    Endpoint, 
    Streams, SendStream, RecvStream, Datagrams, Dir, Event, StreamId,
};
use quinn_proto::StreamEvent::*;

//use log::{info, warn};
use crate::{
    messaging::{DispatchEnvelope, EventEnvelope, NetMessage, SerialisedFrame},
    net::{
        buffers::{BufferChunk, BufferPool, EncodeBuffer},
        udp_state::UdpState,
        quic_config,
        network_thread,
    },
    prelude::{NetworkStatus, SessionId},
    serialisation::ser_helpers::deserialise_chunk_lease,
};
use std::convert::TryInto;
use std::{
    collections::VecDeque,
    collections::HashMap,
    sync::{Arc},
    time::Instant, 
    net::{SocketAddr}, cell::RefCell,
};

const MAX_DATAGRAMS: usize = 10;
#[derive(Debug)]
pub struct QuicEndpoint {
    pub endpoint: Endpoint,
    pub addr: SocketAddr,
    timeout: Option<Instant>,
    pub accepted: Option<ConnectionHandle>,
    pub connections: HashMap<ConnectionHandle, Connection>,
    pub connection_handle: Option<ConnectionHandle>,
    pub conn_events: HashMap<ConnectionHandle, VecDeque<ConnectionEvent>>,
    pub(super) incoming_messages: VecDeque<NetMessage>,

}

impl QuicEndpoint {
    pub fn new(endpoint: Endpoint, 
                addr: SocketAddr, 
               // socket: UdpSocket
            ) -> Self {          
        Self {
            endpoint,
            addr: addr,
            timeout: None,
            //outbound: VecDeque::new(),
            connection_handle: None,
            accepted: None,
            connections: HashMap::default(),
            conn_events: HashMap::default(),
            incoming_messages: VecDeque::new(),

        }
    }
    pub fn conn_mut(&mut self, ch: ConnectionHandle) -> &mut Connection {
        return self.connections.get_mut(&ch).unwrap();
    }
    pub fn streams(&mut self, ch: ConnectionHandle) -> Streams<'_> {
        self.conn_mut(ch).streams()
    }
    pub fn send(&mut self, ch: ConnectionHandle, s: StreamId) -> SendStream<'_> {
        self.conn_mut(ch).send_stream(s)
    }
    pub fn recv(&mut self, ch: ConnectionHandle, s: StreamId) -> RecvStream<'_> {
        self.conn_mut(ch).recv_stream(s)
    }
    pub fn datagrams(&mut self, ch: ConnectionHandle) -> Datagrams<'_> {
        self.conn_mut(ch).datagrams()
    }

    /// start connecting the client
    pub(super) fn connect(&mut self, remote: SocketAddr) -> io::Result<ConnectionHandle> {
        let (client_ch, client_conn) = self
            .endpoint
            .connect(quic_config::client_config(), remote, "localhost")
            .unwrap();
        self.connections.insert(client_ch, client_conn);       
        self.connection_handle = Some(client_ch);
        Ok(client_ch)
    }

    pub(super) fn drive(&mut self, now: Instant, udp_state: &mut UdpState){
        while let Some(x) = self.endpoint.poll_transmit() {
            udp_state.outbound_queue.push_back((x.destination, SerialisedFrame::Vec(x.contents)));
        }

        let mut endpoint_events: Vec<(ConnectionHandle, EndpointEvent)> = vec![];
        for (ch, conn) in self.connections.iter_mut() {
            //Returns packets to transmit
            while let Some(x) = conn.poll_transmit(now, MAX_DATAGRAMS) {
                udp_state.outbound_queue.push_back((x.destination, SerialisedFrame::Vec(x.contents)));
            }
            self.timeout = conn.poll_timeout();

            if self.timeout.map_or(false, |x| x <= now) {
                self.timeout = None;
                conn.handle_timeout(now);
            }

            //Return endpoint-facing events
            while let Some(event) = conn.poll_endpoint_events() {
                endpoint_events.push((*ch, event));
            }
            for (_, mut events) in self.conn_events.drain() {
                for event in events.drain(..) {
                    conn.handle_event(event);
                }
            }
        }

        for (ch, event) in endpoint_events {
            //Process ConnectionEvents generated by the associated Endpoint
            if let Some(event) = self.endpoint.handle_event(ch, event) {
                if let Some(conn) = self.connections.get_mut(&ch) {
                    conn.handle_event(event);
                }
            }
        }
        match udp_state.try_write() {
            Ok(_) => {},
            // Other errors we'll consider fatal.
            Err(err) => {
            }
        }
    }
    pub(super) fn try_read_quic(&mut self, now: Instant, udp_state: &mut UdpState, buffer_pool: &RefCell<BufferPool>, dispatcher_ref: DispatcherRef) -> io::Result<()> { 
        //consume icoming packets and connection-generated events via handle and handle_event
        match udp_state.try_read(buffer_pool) {
            Ok((n, addr)) => {
                let byte_data = udp_state.input_buffer.read_chunk_lease(n);
                let buffer = byte_data.content.to_vec();
                if let Some((ch, event)) =
                    self.endpoint.handle(now, addr, None, None, buffer.as_slice().into())
                {
                    match event {
                        DatagramEvent::NewConnection(conn) => {
                            println!("Accepting new connection from {}", &addr);
                            self.connections.insert(ch, conn);
                            self.accepted = Some(ch);
                        }
                        DatagramEvent::ConnectionEvent(event) => {
                            println!("Redirect to existing connection {:?}", ch);
                            self.conn_events
                            .entry(ch)
                            .or_insert_with(VecDeque::new)
                            .push_back(event);
                        }
                    }
                }
                self.drive(now, udp_state);

                if let Some(mut ch) = self.connection_handle {
                    self.process_quic_events(ch, dispatcher_ref, addr, udp_state);
                }

                self.decode_quic_message(addr, buffer.into());
                return Ok(());
            }
            Err(err) => {
                return Err(err);
            }
        }
    }

    pub(super) fn try_write_quic(&mut self, now: Instant, udp_state: &mut UdpState, dispatcher_ref: DispatcherRef) -> io::Result<()>{
        print!("try_write_quic");
        if let Some(ch) = self.connection_handle {
            println!("some ch in try_write_quic");
            while let Some(x) = self.conn_mut(ch).poll_transmit(now, MAX_DATAGRAMS) {
                println!("some transmit in try_write_quic");
                self.process_quic_events(ch, dispatcher_ref.clone(), x.destination, udp_state);
                udp_state.outbound_queue.push_back((x.destination, SerialisedFrame::Vec(x.contents)));
            }            
        }
        self.drive(now, udp_state);

        match udp_state.try_write(){
            Ok(_) => Ok({}),
            Err(err) => {
                return Err(err);
            },
        }

    }

    pub(super) fn process_quic_events(&mut self, ch: ConnectionHandle, dispatcher_ref: DispatcherRef, addr: SocketAddr, udp_state: &mut UdpState) {
        while let Some(event) = self.conn_mut(ch).poll() {
            println!("SOME EVENT IN PROCESS QUIC EVENTS");
            match event {
                Event::HandshakeDataReady => {
                    println!("Handshake Data Ready {:?}", ch);
                }
                Event::Connected => {
                    eprintln!("Connected {:?}", ch);
                    dispatcher_ref.tell(DispatchEnvelope::Event(EventEnvelope::Network(NetworkStatus::ConnectionEstablished(
                        SystemPath::with_socket(Transport::Quic, addr),
                        SessionId::new_unique()))));
                }
                Event::ConnectionLost { reason } => {
                    println!("lost connection due to {:?}", reason);
                    //TODO fix sessionid
                    dispatcher_ref.tell(DispatchEnvelope::Event(EventEnvelope::Network(NetworkStatus::ConnectionLost(
                        SystemPath::with_socket(Transport::Quic, addr),
                        SessionId::new_unique()))));
                }
                Event::Stream(Opened { dir: Dir::Bi}) => {
                    println!("Stream openend Bi {:?}", ch);

                }
                Event::Stream(Opened { dir: Dir::Uni}) => {
                    println!("Stream openend Uni {:?}", ch);
                }
                Event::Stream(Readable { id: StreamId(_) }) => {
                    println!("Stream readable {:?}", ch);
                    if let Some(mut stream_id) = self.streams(ch).accept(Dir::Bi){
                        let mut receive = self.recv(ch, stream_id);
                        let mut chunks = receive.read(false).unwrap();
                        println!("Read stream");
                        match chunks.next(usize::MAX){
                            Ok(Some(chunk)) => {
                                match ser_helpers::deserialise_bytes(chunk.bytes) {
                                    Ok(envelope) => udp_state.incoming_messages.push_back(envelope),
                                    Err(e) => {
                        
                                    }
                                }
                            }
                            Ok(None) => {
                                println!("NO CHUNKS FROM READ STREAD");

                            }
                            Err(_) => todo!(),

                        }
                        chunks.finalize();
                    }
                }
                Event::Stream(Writable { id: StreamId(_) }) => {
                    println!("Stream writeable {:?}", ch);

                }
                Event::Stream(Finished { id: StreamId(_) }) => {
                    println!("Stream finished {:?}", ch);

                }
                Event::Stream(Stopped { id: StreamId(_), error_code: VarInt }) => {
                    println!("Stream stopped {:?}", ch);

                }
                Event::Stream(Available { dir: Dir::Bi }) => {
                    println!("Stream available Bi {:?}", ch);

                }
                Event::Stream(Available { dir: Dir::Uni }) => {
                    //TODO: send panic since we are not expecting uni direction for this implementation
                    println!("Stream available uni {:?}", ch);

                }
                Event::DatagramReceived => {
                    //TODO: send panic since we are not expecting datagram for this implementation
                    //
                    eprintln!("DatagramReceived {:?}", ch);

                },
            }
        }
    }

    pub fn decode_quic_message(&mut self, source: SocketAddr, buf: Bytes) {
        match ser_helpers::deserialise_bytes(buf) {
            Ok(envelope) => {
                self.incoming_messages.push_back(envelope)
            }
            Err(e) => {
                eprint!(
                    "Could not deserialise Quic messages from {}: {}", source, e
                );
            }
        }
    }

}