use async_std::fs::write;
use async_std::io::ReadExt;
use async_std::stream;
use bitfields::Error;
use bytes::{BytesMut, BufMut, Bytes, Buf};
use tracing::dispatcher;
use tracing::log::logger;
use uuid::Variant;
use super::*;
use quinn_proto::{
    EcnCodepoint,
    ConnectionHandle,
    Connection,
    DatagramEvent,
    EndpointEvent,
    ConnectionEvent,
    Transmit,
    Endpoint,
    Streams, SendStream, RecvStream, Datagrams, Dir, Event, StreamId, Chunks,
};
use quinn_proto::StreamEvent::*;

//use log::{info, warn};
use crate::{
    messaging::{DispatchEnvelope, EventEnvelope, NetMessage, SerialisedFrame},
    net::{
        buffers::{BufferChunk, BufferPool, EncodeBuffer},
        udp_state::UdpState,
        quic_config,
        network_thread,
    },
    prelude::{NetworkStatus, SessionId},
    serialisation::ser_helpers::deserialise_chunk_lease,
};
use std::convert::TryInto;
use std::sync::Arc;
use std::{
    collections::VecDeque,
    collections::HashMap,
    time::Instant,
    net::{SocketAddr}, cell::RefCell,
};

const MAX_DATAGRAMS: usize = 10;
#[derive(Debug)]
pub struct QuicEndpoint {
    pub endpoint: Endpoint,
    pub addr: SocketAddr,
    timeout: Option<Instant>,
    pub accepted: Option<ConnectionHandle>,
    pub connections: HashMap<ConnectionHandle, Connection>,
    pub connection_handle: Option<ConnectionHandle>,
    pub conn_events: HashMap<ConnectionHandle, VecDeque<ConnectionEvent>>,
    pub(super) incoming_messages: VecDeque<NetMessage>,

}

impl QuicEndpoint {
    pub fn new(endpoint: Endpoint,
                addr: SocketAddr,
               // socket: UdpSocket
            ) -> Self {
        Self {
            endpoint,
            addr: addr,
            timeout: None,
            connection_handle: None,
            accepted: None,
            connections: HashMap::default(),
            conn_events: HashMap::default(),
            incoming_messages: VecDeque::new(),
        }
    }
    pub fn conn_mut(&mut self, ch: ConnectionHandle) -> &mut Connection {
        return self.connections.get_mut(&ch).unwrap();
    }
    pub fn streams(&mut self, ch: ConnectionHandle) -> Streams<'_> {
        self.conn_mut(ch).streams()
    }
    pub fn send(&mut self, ch: ConnectionHandle, s: StreamId) -> SendStream<'_> {
        self.conn_mut(ch).send_stream(s)
    }
    pub fn recv(&mut self, ch: ConnectionHandle, s: StreamId) -> RecvStream<'_> {
        self.conn_mut(ch).recv_stream(s)
    }
    pub fn datagrams(&mut self, ch: ConnectionHandle) -> Datagrams<'_> {
        self.conn_mut(ch).datagrams()
    }

    /// start connecting the client
    pub(super) fn connect(&mut self, remote: SocketAddr) -> io::Result<ConnectionHandle> {
        let (client_ch, client_conn) = self
            .endpoint
            .connect(quic_config::client_config(), remote, "localhost")
            .unwrap();
        self.connections.insert(client_ch, client_conn);
        self.connection_handle = Some(client_ch);
        Ok(client_ch)
    }

    pub(super) fn drive(&mut self, now: Instant, udp_state: &mut UdpState){
        while let Some(x) = self.endpoint.poll_transmit() {
            println!("self.endpoint.poll_transmit()");
            udp_state.outbound_queue.push_back((x.destination, SerialisedFrame::Vec(x.contents)));
        }

        let mut endpoint_events: Vec<(ConnectionHandle, EndpointEvent)> = vec![];
        for (ch, conn) in self.connections.iter_mut() {
            //Returns packets to transmit
            while let Some(x) = conn.poll_transmit(now, MAX_DATAGRAMS) {
                println!("conn.poll_transmit()");
                udp_state.outbound_queue.push_back((x.destination, SerialisedFrame::Vec(x.contents)));
            }
            self.timeout = conn.poll_timeout();

            if self.timeout.map_or(false, |x| x <= now) {
                self.timeout = None;
                println!("if timeout");
                conn.handle_timeout(now);
            }

            //Return endpoint-facing events
            while let Some(event) = conn.poll_endpoint_events() {
               println!("conn.poll_endpoint_events()");
                endpoint_events.push((*ch, event));
            }
            for (ch, mut events) in self.conn_events.drain() {
                for event in events.drain(..) {
                    println!("self.conn_events_drain()");
                    conn.handle_event(event);
                }
            }
        }
        for (ch, event) in endpoint_events {
            //Process ConnectionEvents generated by the associated Endpoint
            if let Some(event) = self.endpoint.handle_event(ch, event) {
                if let Some(conn) = self.connections.get_mut(&ch) {
                    println!("self.endpoint.handle_event and connections.get_mut");
                    conn.handle_event(event);
                }
            }
        }
        
       // self.process_quic_events(ch, dispatcher_ref.clone(), udp_state);

        // match udp_state.try_write() {
        //     Ok(_) => {},
        //     // Other errors we'll consider fatal.
        //     Err(err) => {
        //     }
        // }
    }
    pub(super) fn try_read_quic(&mut self, now: Instant, udp_state: &mut UdpState, buffer_pool: &RefCell<BufferPool>, dispatcher_ref: DispatcherRef) -> io::Result<()> {
        //consume icoming packets and connection-generated events via handle and handle_event
        match udp_state.try_read(buffer_pool) {
            Ok((n, addr)) => {
                let data = udp_state.input_buffer.read_chunk_lease(n).content.to_vec().as_slice().into(); 
                if let Some((ch, event)) =
                    self.endpoint.handle(now, addr, None, None, data)
                {
                    match event {
                        DatagramEvent::NewConnection(conn) => {
                            println!("Accepting new connection from {}", &addr);
                            self.connections.insert(ch, conn);
                            self.accepted = Some(ch);
                        }
                        DatagramEvent::ConnectionEvent(event) => {
                            println!("Redirect to existing connection {:?}", ch);
                            self.conn_events
                            .entry(ch)
                            .or_insert_with(VecDeque::new)
                            .push_back(event);
                        }
                    }
                    while let Some(x) = self.endpoint.poll_transmit() {
                        udp_state.outbound_queue.push_back((x.destination, SerialisedFrame::Vec(x.contents)));
                    }

                    let endpoint_events: Vec<(ConnectionHandle, EndpointEvent)> = vec![];
                    for (_ch, conn) in self.connections.iter_mut() {
                        while let Some(x) = conn.poll_transmit(now, MAX_DATAGRAMS) {
                            udp_state.outbound_queue.push_back((x.destination, SerialisedFrame::Vec(x.contents)));
                        }
                        self.timeout = conn.poll_timeout();
            
                        if self.timeout.map_or(false, |x| x <= now) {
                            self.timeout = None;
                            conn.handle_timeout(now);
                        }
            
                        for (_ch, mut events) in self.conn_events.drain() {
                            for event in events.drain(..) {
                                conn.handle_event(event);
                            }
                        }
                    }
                    self.process_quic_events(ch, dispatcher_ref.clone(), udp_state);

                    for (ch, event) in endpoint_events {
                        //Process ConnectionEvents generated by the associated Endpoint
                        if let Some(event) = self.endpoint.handle_event(ch, event) {
                            if let Some(conn) = self.connections.get_mut(&ch) {
                                conn.handle_event(event);
                            }
                        }
                    }
                    self.drive(now, udp_state);

                    self.process_quic_events(ch, dispatcher_ref.clone(), udp_state);
                }

                //println!("BEFORE DRIVE AGAIN");
                //println!("AFTER DRIVE AGAIN");


                match udp_state.try_write() {
                    Ok(_) => {
                        self.drive(now, udp_state);
                    },
                    // Other errors we'll consider fatal.
                    Err(err) => {
                    }
                }

                Ok(())
            }
            Err(err) => {
                return Err(err);
            }
        }
    }

    pub(super) fn try_write_quic(&mut self, now: Instant, udp_state: &mut UdpState, dispatcher_ref: DispatcherRef) -> io::Result<()>{
        self.drive(now, udp_state);
        
        match udp_state.try_write() {
            Ok(_) => {},
            // Other errors we'll consider fatal.
            Err(err) => {
            }
        };
        Ok(())
    }

    pub(super) fn process_quic_events(&mut self, ch: ConnectionHandle, dispatcher_ref: DispatcherRef, udp_state: &mut UdpState) {
       println!("process_quic_events");
        while let Some(event) = self.conn_mut(ch).poll() {
            match event {
                Event::HandshakeDataReady => {
                    println!("Handshake Data Ready {:?}", ch);
                }
                Event::Connected => {
                    println!("Connected {:?} to {:?}", ch, self.conn_mut(ch).remote_address());
                        dispatcher_ref.tell(DispatchEnvelope::Event(EventEnvelope::Network(NetworkStatus::ConnectionEstablished(
                            SystemPath::with_socket(Transport::Quic, self.conn_mut(ch).remote_address()),
                            SessionId::new_unique()))));
                }
                Event::ConnectionLost { reason } => {
                    println!("lost connection due to {:?}", reason);
                    //TODO fix sessionid
                    dispatcher_ref.tell(DispatchEnvelope::Event(EventEnvelope::Network(NetworkStatus::ConnectionLost(
                        SystemPath::with_socket(Transport::Quic, self.conn_mut(ch).remote_address()),
                        SessionId::new_unique()))));
                }
                Event::Stream(Opened { dir: Dir::Bi}) => {
                    println!("Stream openend Bi {:?}", ch);
                    let mut inbound: VecDeque<Bytes> = VecDeque::new();
                    if let Some(mut stream_id) = self.streams(ch).accept(Dir::Bi){
                        let mut receive = self.recv(ch, stream_id);
                        let mut chunks = receive.read(false).unwrap();

                        match chunks.next(usize::MAX){
                           //TODO insert chunks in queue then feed them into ser_helpers function
                           Ok(Some(chunk)) => {
                                inbound.push_back(chunk.bytes);
                            }
                            Ok(None) => {
                                println!("stream is finished");

                            }
                            Err(_) => todo!(),
                        }
                    }
                    println!("inbound.len() {:?}", inbound.len());

                    for byte in inbound.drain(..){
                        self.decode_quic_message(self.addr, byte);
                        //println!("byte {:?}", byte.get_u16_le());
                    }
                }
                Event::Stream(Opened { dir: Dir::Uni}) => {
                    println!("Stream openend Uni {:?}", ch);
                }
                Event::Stream(Readable { id: StreamId(_) }) => {
                    println!("Stream readable {:?}", ch);
                }
                Event::Stream(Writable { id: StreamId(_) }) => {
                    println!("Stream writeable {:?}", ch);

                }
                Event::Stream(Finished { id: StreamId(_) }) => {
                    println!("Stream finished {:?}", ch);

                }
                Event::Stream(Stopped { id: StreamId(_), error_code: VarInt }) => {
                    println!("Stream stopped {:?}", ch);

                }
                Event::Stream(Available { dir: Dir::Bi }) => {
                    println!("Stream available Bi {:?}", ch);

                }
                Event::Stream(Available { dir: Dir::Uni }) => {
                    //TODO: send panic since we are not expecting uni direction for this implementation
                    println!("Stream available uni {:?}", ch);

                }
                Event::DatagramReceived => {
                    //TODO: send panic since we are not expecting datagram for this implementation
                    //
                    eprintln!("DatagramReceived {:?}", ch);

                },
            }
   //     }
    }
    }

    pub fn decode_quic_message(&mut self, source: SocketAddr, buf: Bytes) {
        match ser_helpers::deserialise_bytes(buf) {
            Ok(envelope) => {
                self.incoming_messages.push_back(envelope)
            }
            Err(e) => {
                print!(
                    "Could not deserialise Quic messages from {}: {}", source, e
                );
            }
        }
    }

}